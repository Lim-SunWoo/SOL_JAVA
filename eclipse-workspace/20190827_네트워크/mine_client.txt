package mymain.tcp.multichat;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.GridLayout;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.Socket;
import java.net.UnknownHostException;

import javax.swing.JButton;
import javax.swing.JColorChooser;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;

public class MultiClient extends JFrame {

	JTextArea jta_display;
	JList<String> jlist_user_list;
	JTextField jtf_message;
	JButton jbt_connect;
	boolean bConnect = false; // 연결여부

	Font font = new Font("굴림체", Font.BOLD, 20);

	// 소켓
	Socket client;
	String nick_name = "ililili";

	// 그림판
	JPanel grimPan; // 출력하는 곳
	Image memPan; // (메모리 그림판) - 그리는 곳 (안지워지게 하기 위해서 img) 더블 버퍼링 기법

	int thick = 5;
	int line_color = 0;

	public MultiClient() {
		super("MultiClient"); // JFrame("타이틀") 호출과 같은 기능을 함.

		init_display(); // Center

		init_user_list(); // East

		init_input(); // South 아래

		init_grimpan(); // WEST

		// 위치와 사이즈
		super.setLocation(400, 200);
		// setSize(300, 300);

		setResizable(false);
		pack(); // 클라이언트 크기가 유지 됨.

		// 보이기
		setVisible(true);

		// 종료처리
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		// 메모리 그림판 생성
		memPan = grimPan.createImage(400, 400); // 그림판과 똑같은 이미지를 그림판의 사이즈로 만듬.
	}

	private void init_grimpan() {
		// TODO Auto-generated method stub
		grimPan = new JPanel() { // 패널을 다시 그려야할 필요성이 있을 때 다시 호출.
			@Override
			protected void paintComponent(Graphics g) {
				// TODO Auto-generated method stub
				// 재정의, 메모리화면 내용을 여기로 복사.
				g.drawImage(memPan, 0, 0, this);

			}
		}; // {} -> 객체 생성과 동시에 무언가를 정의. 익명 클래스.
		grimPan.setPreferredSize(new Dimension(400, 400));
		this.add(grimPan, BorderLayout.WEST);

		// 그림판 내에서 마우스가 눌리면
		init_mouse_event();

	}

	private void init_mouse_event() {
		// TODO Auto-generated method stub
		// 마우스도 리스너와 어답터가 있음.
		MouseAdapter adapter = new MouseAdapter() {
			@Override
			public void mouseDragged(MouseEvent e) {
				// TODO Auto-generated method stub
				// 연결되지 않았으면 끝내라
				if (bConnect == false)
					return;

				Point pt = e.getPoint();// 눌린위치

				// 전송 데이터 포장
				String send_data = String.format("DRAW#5d#%d#%d#%d\n", pt.x, pt.y, thick, line_color);

				try {
					// 전송
					client.getOutputStream().write(send_data.getBytes()); // 서버로 전송
				} catch (IOException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}

				/*
				 * // 메모리에 그리기위한 객체 Graphics g = memPan.getGraphics(); g.setColor(new
				 * Color(line_color));
				 * 
				 * g.fillOval(pt.x - thick, pt.y - thick, thick * 2, thick * 2);
				 * 
				 * grimPan.repaint();
				 */
			}
		};
		// 마우스가 움직일때 발생되는 이벤트 처리
		grimPan.addMouseMotionListener(adapter);

	}

	private void init_input() {
		// TODO Auto-generated method stub

		JPanel p = new JPanel(new BorderLayout());
		jtf_message = new JTextField();
		jbt_connect = new JButton("연결");

		jbt_connect.setPreferredSize(new Dimension(120, 0));

		p.add(jtf_message, BorderLayout.CENTER);
		p.add(jbt_connect, BorderLayout.EAST);

		this.add(p, BorderLayout.SOUTH);

		jtf_message.setFont(font);

		// 그림판 메뉴
		JPanel westP = new JPanel(new GridLayout(1, 3));
		westP.setPreferredSize(new Dimension(400, 0));

		p.add(westP, BorderLayout.WEST);

		Integer[] thick_array = { 5, 10, 15, 20, 25, 30 };
		JComboBox<Integer> jcb_thick = new JComboBox<Integer>(thick_array);
		JButton jbt_color = new JButton("선색상");
		JButton jbt_clear = new JButton("지우기");

		westP.add(jcb_thick);
		westP.add(jbt_color);
		westP.add(jbt_clear);

		// 콤보박스 이벤트
		jcb_thick.addItemListener(new ItemListener() {

			@Override
			public void itemStateChanged(ItemEvent e) {
				// TODO Auto-generated method stub
				int state = e.getStateChange();
				if (state == ItemEvent.SELECTED) {
					thick = (int) jcb_thick.getSelectedItem();
					System.out.println(thick);
				}
			}
		});

		// 선색상 이벤트
		jbt_color.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {
				// TODO Auto-generated method stub
				Color color = new Color(line_color);
				Color sel_color = JColorChooser.showDialog(MultiClient.this, "선 색상을 선택하세요.", color); // this// 멀티 클라이언트가
				// 채팅창
				// 선택된 칼라가 널값이면 그만.
				if (sel_color == null)
					return;

				line_color = sel_color.getRGB();
			}
		});

		// 지우기 버튼
		jbt_clear.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {
				// TODO Auto-generated method stub
				Graphics g = memPan.getGraphics();
				g.clearRect(0, 0, 400, 400);
				// ㄴ메모리 그림판 데이터를 지움
				// 다시 그려라.
				grimPan.repaint(); // paint component(Graphics g) Call

			}
		});

		JList<Integer> jList_thick = new JList<Integer>();

		// 키 이벤트
		jtf_message.addKeyListener(new KeyAdapter() {
			@Override
			public void keyPressed(KeyEvent e) {
				// TODO Auto-generated method stub
				super.keyPressed(e);
				my_send_message();

			}

		}); // A.B(C); A에서 B가 발생하면 C에게 위임.

		// 버튼 이벤트
		jbt_connect.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) { // 임장과 퇴장에 동기화를 걸어야함.
				// TODO Auto-generated method stub

				bConnect = !bConnect; // 토글

				if (bConnect) { // 연결
					try {
						client = new Socket("172.16.7.100", 8000);

						// 입장메세지 전달: "IN#홍길동\n"
						String send_data = String.format("IN#%s\n", nick_name);
						client.getOutputStream().write(send_data.getBytes());

						// 데이터 수신
						my_read_message();

					} catch (Exception e1) {
						// TODO Auto-generated catch block
						// e1.printStackTrace();

						my_display_message("연결실패");
						bConnect = false;

					}

				} else { // 끊기
					try {
						client.close();
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						e1.printStackTrace();
					}
				}
				// 버튼 캡션변경
				jbt_connect.setText(bConnect ? "끊기" : "연결");

			}
		});

	}

	protected void my_send_message() {
		// TODO Auto-generated method stub

		// 연결되지 않았으면 끝내라.
		if (bConnect == false)
			return;

		String message = jtf_message.getText().trim();
		if (message.isEmpty()) {
			jtf_message.setText(""); // 공백 지우기
			// 연결을 하면 공백이 많이 들어가도 공백을 제거. (ex. 스페이스 여러번)
			return;
		}
		// 전송 데이터 포장
		String send_data = String.format("MSG#%s#%s\n", nick_name, message);
		// 서버에서 받을 때 한줄 씩 받음. -> 한줄의 끝을 나타내는 정보 > \n 을 꼭 써야함.
		// 안그러면 뒤의 데이터와 붙어버림.
		try {
			client.getOutputStream().write(send_data.getBytes());

		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// 이전 내용 지우기
		jtf_message.setText("");

		// 서버는 받아서 모든 클라이언트에게 전달. -> 서버로 readmessage

	}

	protected void my_read_message() {
		// TODO Auto-generated method stub
		try {
			InputStreamReader isr = new InputStreamReader(client.getInputStream());
			BufferedReader br = new BufferedReader(isr);

			// 수신 스레드
			new Thread() {
				public void run() {
					while (true) {
						try {
							String readStr = br.readLine();
							if (readStr == null)
								break;
							// 수신 메세지를 이용해서 처리
							System.out.println(readStr);

							// readStr = "IN#"홍길동";
							// readStr = "OUT#홍길동";
							// readStr = "MSG#홍길동#잘지내";
							// readStr = "LIST#홍길동1#홍길동2";
							// readStr = "DRAW#x#y#thick#line_color";

							String[] msg_array = readStr.split("#");

							if (msg_array[0].equals("IN")) {
								// 퇴장과 입장은 전부 이름을 받게 되어있음.
								String msg = String.format("[%s]님 입장", msg_array[1]);
								my_display_message(msg);

							} else if (msg_array[0].equals("OUT")) {
								String msg = String.format("[%s]님 퇴장", msg_array[1]);
								my_display_message(msg);

							} else if (msg_array[0].equals("MSG")) {

								// readStr = "MSG#홍길동#잘지내#"
								String msg = String.format("[%s]님 말씀:\r\n   %s", msg_array[1], msg_array[2]);
								my_display_message(msg);

							} else if (msg_array[0].equals("LIST")) {

								my_display_user_list(readStr);

							} else if (msg_array[0].equals("DRAW")) {
								// 0 1 2 3 4
								// readStr = "DRAW#x#y#thick#line_color"
								// 0 1 2 3 4
								// msg_array = {"DRAW","30","50","15","0"};
								int x, y, thick, line_color;

								try {

									x = Integer.parseInt(msg_array[1]);
									y = Integer.parseInt(msg_array[2]);
									thick = Integer.parseInt(msg_array[3]);
									line_color = Integer.parseInt(msg_array[4]);

									// 메모리 그리기
									Graphics g = memPan.getGraphics();
									g.setColor(new Color(line_color));
									g.fillOval(x - thick, y - thick, thick * 2, thick * 2);

									// 메모리->화면으로
									grimPan.repaint();

								} catch (Exception e) {
									// TODO: handle exception
									continue;
								}
							}

						} catch (IOException e) {
							// TODO Auto-generated catch block
							// e.printStackTrace();
							break;
						}

					} // end-while

					System.out.println("---soket close---"); // 고의든 타의든 소켓이 끊기는 부분

					// 사용자 목록 지우기
					String[] user_array = new String[0];
					jlist_user_list.setListData(user_array);
					// 0개짜리 배열을 이용해서 배열을 지움.

					bConnect = false;
					jbt_connect.setText("연결"); // 버튼 초기상태
				}

			}.start();

		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	protected void my_display_user_list(String readStr) {
		// TODO Auto-generated method stub
		// readStr = "LIST#홍길동1#홍길동2#";
		readStr = readStr.replace("LIST#", ""); // LIST#이라는 문자열이 나오면 ""(제거)로 바꾸라
		// readStr = "홍길동1#홍길동2#"; 으로 바뀜.
		jlist_user_list.setListData(readStr.split("#"));

	}

	protected void my_display_message(String message) {
		// TODO Auto-generated method stub
		jta_display.append(message + "\r\n");
		int position = jta_display.getDocument().getLength();
		jta_display.setCaretPosition(position);

	}

	private void init_user_list() {
		// TODO Auto-generated method stub

		jlist_user_list = new JList<String>();
		JScrollPane jsp = new JScrollPane(jlist_user_list);
		jsp.setPreferredSize(new Dimension(120, 0));

		this.add(jsp, BorderLayout.EAST);

		jlist_user_list.setFont(font);

	}

	private void init_display() {
		// TODO Auto-generated method stub
		jta_display = new JTextArea();
		JScrollPane jsp = new JScrollPane(jta_display);

		jsp.setPreferredSize(new Dimension(400, 400));
		this.add(jsp, BorderLayout.CENTER);

		// 읽기전용
		jta_display.setEditable(false);

		jta_display.setFont(font);

		// jta_display.append("--서버대기중--\r\n");

	}

	public static void main(String[] args) {
		new MultiClient();
		// 윈도우를 또 만드려고 할 때 작업의 효울성을 위해 탬플렛을 설정해놓으면 좋음.
	}
}
